<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kaggle Titanic问题(集成学习)</title>
    <link href="/2022/11/03/kaggle%20Titanic%E9%97%AE%E9%A2%98(%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0)/"/>
    <url>/2022/11/03/kaggle%20Titanic%E9%97%AE%E9%A2%98(%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0)/</url>
    
    <content type="html"><![CDATA[<h1 id="Titanic-生存率预测"><a href="#Titanic-生存率预测" class="headerlink" title="Titanic 生存率预测"></a>Titanic 生存率预测</h1><h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>泰坦尼克号（Titanic）问题的背景就是那个大家都熟悉的『Jack and Rose』的故事，豪华游艇倒了，大家都惊恐逃生，可是救生艇的数量有限，无法人人都有，副船长发话了『lady and kid first！』，所以是否获救其实并非随机，而是基于一些背景而有rank先后的。训练和测试数据是一些乘客的个人信息以及存活状况，要尝试根据它生成合适的模型并预测其他人（test.data中的新数据）的存活状况，模型最终结果保存在predictedData.csv中。</p><p>显然，这是一个二分类问题，我们学习使用集成学习方法进行建模求解。<br>数据集下载地址：kaggle官网 <a href="https://www.kaggle.com/competitions/titanic/data">https://www.kaggle.com/competitions/titanic/data</a></p><h3 id="开始加油！"><a href="#开始加油！" class="headerlink" title="开始加油！"></a>开始加油！</h3><p>(ง •̀_•́)ง (*•̀ㅂ•́)و</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#数据处理</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-comment">#import os</span><br><span class="hljs-comment">#绘图</span><br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br><span class="hljs-comment"># matplotlib支持中文</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br><span class="hljs-comment">#各种模型、数据处理方法</span><br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder <span class="hljs-comment"># 对数据进行编码</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split <br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC, LinearSVC <span class="hljs-comment">#支持向量机用于分类</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Perceptron <span class="hljs-comment">#感知机</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDClassifier <span class="hljs-comment">#随机梯度下降分类</span><br><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<br><span class="hljs-keyword">from</span> xgboost <span class="hljs-keyword">import</span> XGBClassifier <br><span class="hljs-keyword">from</span> lightgbm <span class="hljs-keyword">import</span> LGBMClassifier<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV, cross_val_score, StratifiedKFold, learning_curve<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_score <span class="hljs-comment"># 精度是比率tp /（tp + fp）</span><br><br><span class="hljs-keyword">import</span> warnings<br>warnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="二、数据读取和查看"><a href="#二、数据读取和查看" class="headerlink" title="二、数据读取和查看"></a>二、数据读取和查看</h3><p>首先读入数据，并且初步查看数据的记录数，字段数据类型，缺失等信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读入数据</span><br>train_df = pd.read_csv(<span class="hljs-string">&#x27;data/train.csv&#x27;</span>)<br>test_df = pd.read_csv(<span class="hljs-string">&#x27;data/test.csv&#x27;</span>)<br>combine_df = pd.concat([train_df, test_df])<br><span class="hljs-comment"># concat默认拼接方式是上下堆叠</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看数据，展示前5行</span><br>train_df.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>0</td>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>1</td>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>1</td>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>1</td>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>0</td>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看数据类型等信息</span><br>train_df.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 891 entries, 0 to 890Data columns (total 12 columns): #   Column       Non-Null Count  Dtype  ---  ------       --------------  -----   0   PassengerId  891 non-null    int64   1   Survived     891 non-null    int64   2   Pclass       891 non-null    int64   3   Name         891 non-null    object  4   Sex          891 non-null    object  5   Age          714 non-null    float64 6   SibSp        891 non-null    int64   7   Parch        891 non-null    int64   8   Ticket       891 non-null    object  9   Fare         891 non-null    float64 10  Cabin        204 non-null    object  11  Embarked     889 non-null    object dtypes: float64(2), int64(5), object(5)memory usage: 83.7+ KB</code></pre><p>我们可以看到部分数据存在缺失，数据类型多样，后续需要进行相关的数据处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_df.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>714.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>    </tr>    <tr>      <th>mean</th>      <td>446.000000</td>      <td>0.383838</td>      <td>2.308642</td>      <td>29.699118</td>      <td>0.523008</td>      <td>0.381594</td>      <td>32.204208</td>    </tr>    <tr>      <th>std</th>      <td>257.353842</td>      <td>0.486592</td>      <td>0.836071</td>      <td>14.526497</td>      <td>1.102743</td>      <td>0.806057</td>      <td>49.693429</td>    </tr>    <tr>      <th>min</th>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.420000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>    </tr>    <tr>      <th>25%</th>      <td>223.500000</td>      <td>0.000000</td>      <td>2.000000</td>      <td>20.125000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>7.910400</td>    </tr>    <tr>      <th>50%</th>      <td>446.000000</td>      <td>0.000000</td>      <td>3.000000</td>      <td>28.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>14.454200</td>    </tr>    <tr>      <th>75%</th>      <td>668.500000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>38.000000</td>      <td>1.000000</td>      <td>0.000000</td>      <td>31.000000</td>    </tr>    <tr>      <th>max</th>      <td>891.000000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>80.000000</td>      <td>8.000000</td>      <td>6.000000</td>      <td>512.329200</td>    </tr>  </tbody></table></div><p>以上包含数值型数据（Numerical data）的统计特征</p><h3 id="三、数据探索与变量分析"><a href="#三、数据探索与变量分析" class="headerlink" title="三、数据探索与变量分析"></a>三、数据探索与变量分析</h3><p>首先通过pandas的corr()函数计算相关系数矩阵，初步探索各个字段与预测变量“Survived”的关系以及各个变量之间的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过相关系数矩阵初步观察特征与“Survived&quot;的关系</span><br><br>train_df_corr = train_df.drop(<span class="hljs-string">&#x27;PassengerId&#x27;</span>,axis=<span class="hljs-number">1</span>).corr()<br><br>f, ax = plt.subplots(figsize=(<span class="hljs-number">9</span>,<span class="hljs-number">6</span>))<br>plt.style.use(<span class="hljs-string">&#x27;ggplot&#x27;</span>)<br>sns.set_style(<span class="hljs-string">&#x27;darkgrid&#x27;</span>)<br>sns.<span class="hljs-built_in">set</span>(context=<span class="hljs-string">&quot;paper&quot;</span>, font=<span class="hljs-string">&quot;monospace&quot;</span>)<br><br>hm = sns.heatmap(train_df_corr, cmap=sns.diverging_palette(<span class="hljs-number">20</span>, <span class="hljs-number">220</span>, n=<span class="hljs-number">200</span>),cbar=<span class="hljs-literal">True</span>, annot=<span class="hljs-literal">True</span>, square=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">&#x27;.3f&#x27;</span>,<br>                 annot_kws=&#123;<span class="hljs-string">&#x27;size&#x27;</span>:<span class="hljs-number">12</span>&#125;)<span class="hljs-comment"># 使用了seaborn的diverging_palette调色</span><br>ax.set_xticklabels(train_df_corr.index, size=<span class="hljs-number">11</span>)<br>ax.set_yticklabels(train_df_corr.columns[:], size=<span class="hljs-number">11</span>)<br>ax.set_title(<span class="hljs-string">&#x27;train feature corr&#x27;</span>, fontsize=<span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 1.0, &#39;train feature corr&#39;)</code></pre><p><img src="/img/output_11_1.png"><br>​    </p><p>根据相关系数矩阵，我们初步分析可知：</p><ol><li>Fare（乘客费用）、Parch（同行的家长和孩子数目）与“Survived”正相关。<br>数据显示高费用顾客更可能获救；</li><li>SibSp（同行的兄弟姐妹和配偶数目）、Age（年龄）、Pclass（用户阶级）与<br>“Survived”负相关；其中Pclass的值越小用户所属的等级越高，表示等级高的乘客更可能获救，这是具有一定的合理性的。<br>……</li></ol><h3 id="四、特征探索"><a href="#四、特征探索" class="headerlink" title="四、特征探索"></a>四、特征探索</h3><h4 id="4-1-年龄（Name）"><a href="#4-1-年龄（Name）" class="headerlink" title="4.1 年龄（Name）"></a>4.1 年龄（Name）</h4><p>我们将可视化展示训练数据集中年龄的整体分布以及dead和alive乘客的数量分布统计。并进行对比分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br>fig, axes = plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>sns.distplot(train_df.Age.dropna(), rug=<span class="hljs-literal">True</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, ax=axes[<span class="hljs-number">0</span>])<br>ax0 = axes[<span class="hljs-number">0</span>]<br>ax0.tick_params(labelsize=<span class="hljs-number">10</span>)<br>ax0.set_title(<span class="hljs-string">&#x27;age distribution&#x27;</span>,fontsize=<span class="hljs-number">12</span>)<br>ax0.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>ax0.set_ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>ax1 = axes[<span class="hljs-number">1</span>]<br><span class="hljs-comment"># ax1.set_title(&#x27;age survived distribution&#x27;)</span><br>k1 = sns.distplot(train_df[train_df.Survived==<span class="hljs-number">0</span>].Age.dropna(), hist=<span class="hljs-literal">False</span>, color=<span class="hljs-string">&#x27;y&#x27;</span>, ax=ax1, label=<span class="hljs-string">&#x27;dead&#x27;</span>)<br>k2 = sns.distplot(train_df[train_df.Survived==<span class="hljs-number">1</span>].Age.dropna(), hist=<span class="hljs-literal">False</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>, ax=ax1, label=<span class="hljs-string">&#x27;alive&#x27;</span>)<br>ax1.tick_params(labelsize=<span class="hljs-number">10</span>)<br>ax1.set_xlabel(<span class="hljs-string">&#x27;age survived distribution&#x27;</span>,fontsize=<span class="hljs-number">12</span>)<br>ax1.set_ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>ax1.legend(fontsize=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x24b9bfaffd0&gt;</code></pre><p><img src="/img/output_14_1.png"></p><p>乘客的年龄集中在20-40岁，所以主要为青年人和中年人。从age survived distribution表中我们可以发现，小孩获救似乎更容易一些，这个结果也有一定的社会基础，灾难时刻，大多数人可能选择站出来保护妇女和儿童。</p><h4 id="4-2-用户阶级（Pclass）"><a href="#4-2-用户阶级（Pclass）" class="headerlink" title="4.2 用户阶级（Pclass）"></a>4.2 用户阶级（Pclass）</h4><p>我们绘制柱形图展示不同Pclass（1， 2 ， 3）的乘客获救与未获救的数量，以对比发现Pclass与“Survived”的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">y_dead = train_df[train_df.Survived==<span class="hljs-number">0</span>].groupby(<span class="hljs-string">&#x27;Pclass&#x27;</span>)[<span class="hljs-string">&#x27;Survived&#x27;</span>].count()<br>y_alive = train_df[train_df.Survived==<span class="hljs-number">1</span>].groupby(<span class="hljs-string">&#x27;Pclass&#x27;</span>)[<span class="hljs-string">&#x27;Survived&#x27;</span>].count()<br><br>pos = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>ax = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)).add_subplot(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>ax.bar(pos, y_dead, color=<span class="hljs-string">&#x27;r&#x27;</span>, alpha=<span class="hljs-number">0.5</span>, label=<span class="hljs-string">&#x27;dead&#x27;</span>)<br>ax.bar(pos, y_alive, color=<span class="hljs-string">&#x27;b&#x27;</span>, bottom=y_dead, alpha=<span class="hljs-number">0.5</span>, label=<span class="hljs-string">&#x27;alive&#x27;</span>)<br>ax.legend(fontsize=<span class="hljs-number">15</span>, loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br>ax.set_xticks(pos)<br>ax.set_xticklabels([<span class="hljs-string">&#x27;Pclass %d&#x27;</span>%(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)], size=<span class="hljs-number">12</span>)<br>ax.set_title(<span class="hljs-string">&#x27;Pclass Surveved count&#x27;</span>, size=<span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 1.0, &#39;Pclass Surveved count&#39;)</code></pre><p><img src="/img/output_17_1.png"></p><p>Pclass从1至3等级递减，即1可以理解为头等乘客。我们发现在Pclass=1的记录中，乘客的获救比例明显最高，这是一个有趣的现象。或许更高等的乘客配备了更好的保护措施。</p><h4 id="4-3-性别（Sex）"><a href="#4-3-性别（Sex）" class="headerlink" title="4.3 性别（Sex）"></a>4.3 性别（Sex）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 统计性别和获救的数量</span><br><br><span class="hljs-built_in">print</span>(train_df.Sex.value_counts())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------------------------------&#x27;</span>)<br><span class="hljs-built_in">print</span>(train_df.groupby(<span class="hljs-string">&#x27;Sex&#x27;</span>)[<span class="hljs-string">&#x27;Survived&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">male      577female    314Name: Sex, dtype: int64-------------------------------Sexfemale    0.742038male      0.188908Name: Survived, dtype: float64</code></pre><p>我们注意到，男性的数量偏多，同时数据展现出来的女性的存活率（0.742038）远远高于男性（0.188908）<br>这符合我们在年龄（Name）中的有关猜想。我们在后续的特征处理中应该注意这一特点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># violinplot(小提琴图)可视化展示</span><br><br>ax = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">5</span>)).add_subplot(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>sns.violinplot(x=<span class="hljs-string">&#x27;Sex&#x27;</span>, y=<span class="hljs-string">&#x27;Age&#x27;</span>, hue=<span class="hljs-string">&#x27;Survived&#x27;</span>, palette=<span class="hljs-string">&quot;Set2&quot;</span>, data=train_df.dropna(), split=<span class="hljs-literal">True</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;Sex&#x27;</span>, size=<span class="hljs-number">13</span>)<br>ax.set_xticklabels([<span class="hljs-string">&#x27;Female&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>], size=<span class="hljs-number">12</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;Age&#x27;</span>, size=<span class="hljs-number">13</span>)<br>ax.legend(fontsize=<span class="hljs-number">12</span>,loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.legend.Legend at 0x24b9e256f40&gt;</code></pre><p><img src="/img/output_22_1.png"></p><p>图例中0表示’Survived’=0，即未获救；图表具有多个维度，可以反映不同性别以及是否获救的乘客的大致分布情况。<br>分析结果显示，无论男女中青年容易获救；相比于女性，男性老年和小孩的获救比例更大。</p><h4 id="4-4-Frae-票价"><a href="#4-4-Frae-票价" class="headerlink" title="4.4 Frae(票价)"></a>4.4 Frae(票价)</h4><p>我们分别绘制票价的总体分布图和dead和alive类型的票价分布对比图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 票价的总体分布图</span><br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>))<br>ax = plt.subplot2grid((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br><br>ax.tick_params(labelsize=<span class="hljs-number">10</span>)<br>ax.set_title(<span class="hljs-string">&#x27;Fare dist&#x27;</span>, size=<span class="hljs-number">13</span>)<br>sns.kdeplot(train_df.Fare, ax=ax)<br>sns.distplot(train_df.Fare,label=<span class="hljs-string">&#x27;fare&#x27;</span>, ax=ax)<br>ax.legend(fontsize=<span class="hljs-number">15</span>)<br>pos = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">201</span>,<span class="hljs-number">25</span>)<br>ax.set_xticks(pos)<br>ax.set_xlim([<span class="hljs-number">0</span>, <span class="hljs-number">200</span>])<br>ax.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># dead和alive分别统计的票价分布曲线对比图</span><br>ax1 = plt.subplot2grid((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), colspan=<span class="hljs-number">2</span>)<br>ax1.tick_params(labelsize=<span class="hljs-number">10</span>)<br>sns.distplot(train_df[train_df.Survived==<span class="hljs-number">0</span>].Fare, ax=ax1,hist=<span class="hljs-literal">False</span>, label=<span class="hljs-string">&#x27;dead&#x27;</span>, color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>sns.distplot(train_df[train_df.Survived==<span class="hljs-number">1</span>].Fare, ax=ax1,hist=<span class="hljs-literal">False</span>, label=<span class="hljs-string">&#x27;alive&#x27;</span>,  color=<span class="hljs-string">&#x27;b&#x27;</span>)<br>ax1.set_xlim([<span class="hljs-number">0</span>,<span class="hljs-number">200</span>])<br>ax1.legend(fontsize=<span class="hljs-number">12</span>)<br><br>ax1.set_xlabel(<span class="hljs-string">&#x27;Fare&#x27;</span>, size=<span class="hljs-number">12</span>)<br>ax1.set_ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;&#39;)</code></pre><p><img src="/img/output_25_1.png"></p><p>图中可以看到，低票价（Fare）的乘客中死亡比例极高，而高票价的乘客中获救的人似乎要更多。<br>同时我们注意到，Fare的分布太宽，后续数据处理可以做一下scaling，加速模型收敛。</p><h4 id="4-5-表亲和直亲-SibSp和Parch"><a href="#4-5-表亲和直亲-SibSp和Parch" class="headerlink" title="4.5 表亲和直亲(SibSp和Parch)"></a>4.5 表亲和直亲(SibSp和Parch)</h4><p>SibSp描述了泰坦尼克号上与乘客同行的兄弟姐妹（Siblings）和配偶（Spouse）数目；<br>而Parch描述了泰坦尼克号上与乘客同行的家长（Parents）和孩子（Children）数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先查看数据分布特征</span><br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>))<br>ax1 = fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>sns.countplot(train_df.SibSp)<br>ax1.set_title(<span class="hljs-string">&#x27;SibSp&#x27;</span>, size=<span class="hljs-number">13</span>)<br>ax1.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>ax1.set_ylabel(<span class="hljs-string">&#x27;Count&#x27;</span>,size=<span class="hljs-number">11</span>)<br><br>ax2 = fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, sharex=ax1)<br>sns.countplot(train_df.Parch)<br>ax2.set_xlabel(<span class="hljs-string">&#x27;Parch&#x27;</span>, size=<span class="hljs-number">13</span>)<br>ax2.set_ylabel(<span class="hljs-string">&#x27;Count&#x27;</span>,size=<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;Count&#39;)</code></pre><p><img src="/img/output_28_1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 统计对比不同sibsp &amp; parch情况下的获救比例</span><br><br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))<br>ax1 = fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>train_df.groupby(<span class="hljs-string">&#x27;SibSp&#x27;</span>)[<span class="hljs-string">&#x27;Survived&#x27;</span>].mean().plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>,ax= ax1,color=<span class="hljs-string">&#x27;lightseagreen&#x27;</span>)<br>ax1.set_title(<span class="hljs-string">&#x27;Sibsp Survived Rate&#x27;</span>, size=<span class="hljs-number">12</span>)<br>ax1.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>ax2 = fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>train_df.groupby(<span class="hljs-string">&#x27;Parch&#x27;</span>)[<span class="hljs-string">&#x27;Survived&#x27;</span>].mean().plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>,ax= ax2,color=<span class="hljs-string">&#x27;m&#x27;</span>)<br>ax2.set_title(<span class="hljs-string">&#x27;Parch Survived Rate&#x27;</span>, size=<span class="hljs-number">12</span>)<br>ax2.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 0, &#39;&#39;)</code></pre><p><img src="/img/output_29_1.png"></p><p>分组统计不同亲戚类型,即表亲和直亲(SibSp和Parch)和数量的获救率。我们发现，获救率与亲戚的关系可能并不具有简单的线性关系。</p><h3 id="五、特征工程"><a href="#五、特征工程" class="headerlink" title="五、特征工程"></a>五、特征工程</h3><h4 id="5-1-Name特征处理"><a href="#5-1-Name特征处理" class="headerlink" title="5.1 Name特征处理"></a>5.1 Name特征处理</h4><p>充分挖掘和提取Titanic数据集的特征可以有效提高模型精度。因此，我们对name字段进行挖掘和特征的提取</p><h4 id="5-2-Name-Len特征"><a href="#5-2-Name-Len特征" class="headerlink" title="5.2 Name_Len特征"></a>5.2 Name_Len特征</h4><p>由于西方人的名字长度差别较大，且含义丰富，我们首先探索一下名字长度这个特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">train_df.groupby(train_df.Name.apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x)))[<span class="hljs-string">&#x27;Survived&#x27;</span>].mean().plot(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">5</span>),linewidth=<span class="hljs-number">2</span>,color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Name_length&#x27;</span>,fontsize=<span class="hljs-number">12</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Survived rate&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0, 0.5, &#39;Survived rate&#39;)</code></pre><p><img src="/img/output_33_1.png"></p><p>可以看到名字的长度和获救率还是有一定的正向关系的，可以考虑加入Name_Len特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加入Name_Len特征</span><br>combine_df[<span class="hljs-string">&#x27;Name_Len&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Name&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x))<br><br><span class="hljs-comment"># Name_Len数据分箱</span><br>combine_df[<span class="hljs-string">&#x27;Name_Len&#x27;</span>] = pd.qcut(combine_df[<span class="hljs-string">&#x27;Name_Len&#x27;</span>],<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p>数据分箱（也称为离散分箱或分段）是一种数据预处理技术，用于减少次要观察误差的影响，是一种将多个连续值分组为较少数量的“分箱”的方法。</p><h4 id="5-3-Title特征"><a href="#5-3-Title特征" class="headerlink" title="5.3 Title特征"></a>5.3 Title特征</h4><p>西方人名字中含有的称谓信息(数据集中名字中间的单词)也可以在很大程度上反映一个人的身份地位，从数据中提取”Title”（称谓）也可以作为特征，由于有些称谓的人数量过少，我们还需要做一个映射（分组），将一组等效的称谓合并在一起。</p><p>几条有关英语称谓的解释：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Mme：</strong>相当于Mrs</td><td><strong>Ms：</strong>Ms.或Mz 美国近来用来称呼婚姻状态不明的妇女</td></tr><tr><td><strong>Jonkheer:</strong> 乡绅</td><td><strong>Col：</strong>中校:Lieutenant Colonel(Lt. Col.)上校:Colonel(Col.)</td></tr><tr><td><strong>Lady：</strong>贵族夫人的称呼</td><td><strong>Major：</strong>少校</td></tr><tr><td><strong>Don唐：</strong>是西班牙语中贵族和有地位者的尊称</td><td><strong>Mlle:</strong> 小姐</td></tr><tr><td><strong>sir：</strong>懂的都懂</td><td><strong>Rev：</strong>牧师</td></tr><tr><td><strong>the Countess：</strong>女伯爵</td><td><strong>测试集合中的Dona</strong>：女士尊称</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 称谓的提取和合并</span><br>combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Name&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&#x27;, &#x27;</span>)[<span class="hljs-number">1</span>]).apply(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>])<br>combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>].replace([<span class="hljs-string">&#x27;Don&#x27;</span>,<span class="hljs-string">&#x27;Dona&#x27;</span>, <span class="hljs-string">&#x27;Major&#x27;</span>, <span class="hljs-string">&#x27;Capt&#x27;</span>, <span class="hljs-string">&#x27;Jonkheer&#x27;</span>, <span class="hljs-string">&#x27;Rev&#x27;</span>, <span class="hljs-string">&#x27;Col&#x27;</span>,<span class="hljs-string">&#x27;Sir&#x27;</span>,<span class="hljs-string">&#x27;Dr&#x27;</span>],<span class="hljs-string">&#x27;Mr&#x27;</span>)<br>combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>].replace([<span class="hljs-string">&#x27;Mlle&#x27;</span>,<span class="hljs-string">&#x27;Ms&#x27;</span>], <span class="hljs-string">&#x27;Miss&#x27;</span>)<br>combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>].replace([<span class="hljs-string">&#x27;the Countess&#x27;</span>,<span class="hljs-string">&#x27;Mme&#x27;</span>,<span class="hljs-string">&#x27;Lady&#x27;</span>,<span class="hljs-string">&#x27;Dr&#x27;</span>], <span class="hljs-string">&#x27;Mrs&#x27;</span>)<br><br><span class="hljs-comment"># 分类变量编码，转换为哑变量处理</span><br>df = pd.get_dummies(combine_df[<span class="hljs-string">&#x27;Title&#x27;</span>],prefix=<span class="hljs-string">&#x27;Title&#x27;</span>)<span class="hljs-comment"># prefix：表示列名的前缀</span><br>combine_df = pd.concat([combine_df,df],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在特征探索阶段，我们发现男性和女性的获救率分别为女性的0.742038和男性的0.188908；<br>女性死亡以及男性存活概率明显较低，为了提升模型对于这一类群体的识别能力，我们分析数据并找到了一个重要特征“Family”，同一个family下的生存死亡模式有很大程度上是相关的，例如：有一个family有一个女性死亡，这个family其他的女性的死亡概率也比较高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#我们标注出这些特殊的family</span><br><br>combine_df[<span class="hljs-string">&#x27;Surname&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Name&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x:x.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>])<br>dead_female_surname = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(combine_df[(combine_df.Sex==<span class="hljs-string">&#x27;female&#x27;</span>) &amp; (combine_df.Age&gt;=<span class="hljs-number">12</span>)<br>                              &amp; (combine_df.Survived==<span class="hljs-number">0</span>) &amp; ((combine_df.Parch&gt;<span class="hljs-number">0</span>) | (combine_df.SibSp &gt; <span class="hljs-number">0</span>))][<span class="hljs-string">&#x27;Surname&#x27;</span>].values))<br>survive_male_surname = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(combine_df[(combine_df.Sex==<span class="hljs-string">&#x27;male&#x27;</span>) &amp; (combine_df.Age&gt;=<span class="hljs-number">12</span>)<br>                              &amp; (combine_df.Survived==<span class="hljs-number">1</span>) &amp; ((combine_df.Parch&gt;<span class="hljs-number">0</span>) | (combine_df.SibSp &gt; <span class="hljs-number">0</span>))][<span class="hljs-string">&#x27;Surname&#x27;</span>].values))<br>combine_df[<span class="hljs-string">&#x27;Dead_female_family&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Surname&#x27;</span>].isin(dead_female_surname),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>combine_df[<span class="hljs-string">&#x27;Survive_male_family&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Surname&#x27;</span>].isin(survive_male_surname),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>combine_df = combine_df.drop([<span class="hljs-string">&#x27;Name&#x27;</span>,<span class="hljs-string">&#x27;Surname&#x27;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-4-Age特征"><a href="#5-4-Age特征" class="headerlink" title="5.4  Age特征"></a>5.4  Age特征</h4><p>根据特征探索阶段的分析，小孩的获救率明显较高，可以添加一个小孩标签属性（IsChild）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Age &amp; isChild</span><br>group = combine_df.groupby([<span class="hljs-string">&#x27;Title&#x27;</span>, <span class="hljs-string">&#x27;Pclass&#x27;</span>])[<span class="hljs-string">&#x27;Age&#x27;</span>]<br>combine_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = group.transform(<span class="hljs-keyword">lambda</span> x: x.fillna(x.median()))<br>combine_df = combine_df.drop(<span class="hljs-string">&#x27;Title&#x27;</span>,axis=<span class="hljs-number">1</span>)<br>combine_df[<span class="hljs-string">&#x27;IsChild&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Age&#x27;</span>]&lt;=<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>combine_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = pd.cut(combine_df[<span class="hljs-string">&#x27;Age&#x27;</span>],<span class="hljs-number">5</span>)<br>combine_df = combine_df.drop(<span class="hljs-string">&#x27;Age&#x27;</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-5-Familysize"><a href="#5-5-Familysize" class="headerlink" title="5.5  Familysize"></a>5.5  Familysize</h4><p>将上面提取过的Familysize再离散化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分箱，将Familysize=0标注为&#x27;solo&#x27;,Familysize&gt;3为&#x27;big&#x27;，中间为&#x27;normal&#x27;，然后对分类变量编码，转换为哑变量处理</span><br><br>combine_df[<span class="hljs-string">&#x27;FamilySize&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>]+combine_df[<span class="hljs-string">&#x27;Parch&#x27;</span>]==<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Alone&#x27;</span>,<br>                                    np.where(combine_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>]+combine_df[<span class="hljs-string">&#x27;Parch&#x27;</span>]&lt;=<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Small&#x27;</span>, <span class="hljs-string">&#x27;Big&#x27;</span>))<br>df = pd.get_dummies(combine_df[<span class="hljs-string">&#x27;FamilySize&#x27;</span>],prefix=<span class="hljs-string">&#x27;FamilySize&#x27;</span>)<br>combine_df = pd.concat([combine_df,df],axis=<span class="hljs-number">1</span>).drop([<span class="hljs-string">&#x27;SibSp&#x27;</span>,<span class="hljs-string">&#x27;Parch&#x27;</span>,<span class="hljs-string">&#x27;FamilySize&#x27;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-6-Ticket特征"><a href="#5-6-Ticket特征" class="headerlink" title="5.6 Ticket特征"></a>5.6 Ticket特征</h4><p>统计发现，【’1’, ‘2’, ‘P’】开头的Ticket获救率更高。可以标注为’High_Survival_Ticket’型票；同理【’A’,’W’,’3’,’7’】为’Low_Survival_Ticket’型票。这样得到High_Survival_Ticket和Low_Survival_Ticket两个新的特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">combine_df[<span class="hljs-string">&#x27;Ticket_Lett&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Ticket&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">str</span>(x)[<span class="hljs-number">0</span>])<br>combine_df[<span class="hljs-string">&#x27;Ticket_Lett&#x27;</span>] = combine_df[<span class="hljs-string">&#x27;Ticket_Lett&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">str</span>(x))<br><br>combine_df[<span class="hljs-string">&#x27;High_Survival_Ticket&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Ticket_Lett&#x27;</span>].isin([<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>]),<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>combine_df[<span class="hljs-string">&#x27;Low_Survival_Ticket&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Ticket_Lett&#x27;</span>].isin([<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;W&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>]),<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>combine_df = combine_df.drop([<span class="hljs-string">&#x27;Ticket&#x27;</span>,<span class="hljs-string">&#x27;Ticket_Lett&#x27;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-7-Embarked特征"><a href="#5-7-Embarked特征" class="headerlink" title="5.7 Embarked特征"></a>5.7 Embarked特征</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">3</span>)).add_subplot(<span class="hljs-number">111</span>)<br>ax.set_xlim([-<span class="hljs-number">20</span>, <span class="hljs-number">80</span>])<br>sns.kdeplot(train_df[train_df.Embarked==<span class="hljs-string">&#x27;C&#x27;</span>].Age.dropna(), ax=ax, label=<span class="hljs-string">&#x27;C&#x27;</span>)<br>sns.kdeplot(train_df[train_df.Embarked==<span class="hljs-string">&#x27;Q&#x27;</span>].Age.dropna(), ax=ax, label=<span class="hljs-string">&#x27;Q&#x27;</span>)<br>sns.kdeplot(train_df[train_df.Embarked==<span class="hljs-string">&#x27;S&#x27;</span>].Age.dropna(), ax=ax, label=<span class="hljs-string">&#x27;S&#x27;</span>)<br>ax.legend(fontsize=<span class="hljs-number">12</span>)<br>ax.set_title(<span class="hljs-string">&#x27;Embarked Age Dist &#x27;</span>, size=<span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Text(0.5, 1.0, &#39;Embarked Age Dist &#39;)</code></pre><p><img src="/img/output_49_1.png"></p><p>Embarked字段只有个别缺失，我们选择数量最多且年龄分布正常的港口进行填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 缺失港口信息填充S，并转换为哑变量</span><br><br>combine_df.Embarked = combine_df.Embarked.fillna(<span class="hljs-string">&#x27;S&#x27;</span>)<br>df = pd.get_dummies(combine_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>],prefix=<span class="hljs-string">&#x27;Embarked&#x27;</span>)<br>combine_df = pd.concat([combine_df,df],axis=<span class="hljs-number">1</span>).drop(<span class="hljs-string">&#x27;Embarked&#x27;</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-8-Cabin特征"><a href="#5-8-Cabin特征" class="headerlink" title="5.8 Cabin特征"></a>5.8 Cabin特征</h4><p>Cabin特征大量缺失，我们将其转化为Cabin_isNull特征，取值域为0和1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">combine_df[<span class="hljs-string">&#x27;Cabin_isNull&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>].isnull(),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>combine_df = combine_df.drop(<span class="hljs-string">&#x27;Cabin&#x27;</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-9-Pclass-amp-Sex特征"><a href="#5-9-Pclass-amp-Sex特征" class="headerlink" title="5.9 Pclass &amp; Sex特征"></a>5.9 Pclass &amp; Sex特征</h4><p>Pclass &amp; Sex特征进行分类数据编码，转化为哑变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Pclass</span><br>df = pd.get_dummies(combine_df[<span class="hljs-string">&#x27;Pclass&#x27;</span>],prefix=<span class="hljs-string">&#x27;Pclass&#x27;</span>)<br>combine_df = pd.concat([combine_df,df],axis=<span class="hljs-number">1</span>).drop(<span class="hljs-string">&#x27;Pclass&#x27;</span>,axis=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># Sex</span><br>df = pd.get_dummies(combine_df[<span class="hljs-string">&#x27;Sex&#x27;</span>],prefix=<span class="hljs-string">&#x27;Sex&#x27;</span>)<br>combine_df = pd.concat([combine_df,df],axis=<span class="hljs-number">1</span>).drop(<span class="hljs-string">&#x27;Sex&#x27;</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="5-10-Fare特征"><a href="#5-10-Fare特征" class="headerlink" title="5.10 Fare特征"></a>5.10 Fare特征</h4><p>缺省值用众数填充，之后进行离散化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Fare</span><br>combine_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].fillna(combine_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].dropna().median(),inplace=<span class="hljs-literal">True</span>)<br>combine_df[<span class="hljs-string">&#x27;Low_Fare&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Fare&#x27;</span>]&lt;=<span class="hljs-number">8.662</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>combine_df[<span class="hljs-string">&#x27;High_Fare&#x27;</span>] = np.where(combine_df[<span class="hljs-string">&#x27;Fare&#x27;</span>]&gt;=<span class="hljs-number">26</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>combine_df = combine_df.drop(<span class="hljs-string">&#x27;Fare&#x27;</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="六、-模型训练-测试"><a href="#六、-模型训练-测试" class="headerlink" title="六、 模型训练/测试"></a>六、 模型训练/测试</h3><p>查看我们现在有哪些特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">combine_df.columns<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Name_Len&#39;, &#39;Title_Master&#39;, &#39;Title_Miss&#39;,       &#39;Title_Mr&#39;, &#39;Title_Mrs&#39;, &#39;Dead_female_family&#39;, &#39;Survive_male_family&#39;,       &#39;IsChild&#39;, &#39;FamilySize_Alone&#39;, &#39;FamilySize_Big&#39;, &#39;FamilySize_Small&#39;,       &#39;High_Survival_Ticket&#39;, &#39;Low_Survival_Ticket&#39;, &#39;Embarked_C&#39;,       &#39;Embarked_Q&#39;, &#39;Embarked_S&#39;, &#39;Cabin_isNull&#39;, &#39;Pclass_1&#39;, &#39;Pclass_2&#39;,       &#39;Pclass_3&#39;, &#39;Sex_female&#39;, &#39;Sex_male&#39;, &#39;Low_Fare&#39;, &#39;High_Fare&#39;],      dtype=&#39;object&#39;)</code></pre><p>所有特征转化成数值型编码：</p><p>LabelEncoder是用来对分类型特征值进行编码，即对不连续的数值或文本进行编码。其中包含以下常用方法：</p><ol><li>fit(y) ：fit可看做一本空字典，y可看作要塞到字典中的词。</li><li>fit_transform(y)：相当于先进行fit再进行transform，即把y塞到字典中去以后再进行transform得到索引值。</li><li>inverse_transform(y)：根据索引值y获得原始数据。</li><li>transform(y) ：将y转变成索引值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">features = combine_df.drop([<span class="hljs-string">&quot;PassengerId&quot;</span>,<span class="hljs-string">&quot;Survived&quot;</span>], axis=<span class="hljs-number">1</span>).columns<br>le = LabelEncoder()<br><span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features:<br>    combine_df[feature]=le.fit_transform(combine_df[feature])<br>    <span class="hljs-comment"># 和以下两行等价</span><br>    <span class="hljs-comment"># le = le.fit(combine_df[feature])# fit(),将所有特征转化成数值型编码</span><br>    <span class="hljs-comment"># combine_df[feature] = le.transform(combine_df[feature])</span><br>combine_df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code class="hljs">.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Name_Len</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Dead_female_family</th>      <th>Survive_male_family</th>      <th>IsChild</th>      <th>...</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>      <th>Cabin_isNull</th>      <th>Pclass_1</th>      <th>Pclass_2</th>      <th>Pclass_3</th>      <th>Sex_female</th>      <th>Sex_male</th>      <th>Low_Fare</th>      <th>High_Fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>0.0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>1.0</td>      <td>4</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>1.0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>1.0</td>      <td>4</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>0.0</td>      <td>2</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>413</th>      <td>1305</td>      <td>NaN</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>414</th>      <td>1306</td>      <td>NaN</td>      <td>3</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>415</th>      <td>1307</td>      <td>NaN</td>      <td>3</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>416</th>      <td>1308</td>      <td>NaN</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>417</th>      <td>1309</td>      <td>NaN</td>      <td>2</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>...</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><p>1309 rows × 26 columns</p></div><h4 id="6-1-模型搭建"><a href="#6-1-模型搭建" class="headerlink" title="6.1 模型搭建"></a>6.1 模型搭建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">X_all = combine_df.iloc[:<span class="hljs-number">891</span>,:].drop([<span class="hljs-string">&quot;PassengerId&quot;</span>,<span class="hljs-string">&quot;Survived&quot;</span>], axis=<span class="hljs-number">1</span>)<br>Y_all = combine_df.iloc[:<span class="hljs-number">891</span>,:][<span class="hljs-string">&quot;Survived&quot;</span>]<br>X_test = combine_df.iloc[<span class="hljs-number">891</span>:,:].drop([<span class="hljs-string">&quot;PassengerId&quot;</span>,<span class="hljs-string">&quot;Survived&quot;</span>], axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="6-2-模型与参数初始化"><a href="#6-2-模型与参数初始化" class="headerlink" title="6.2 模型与参数初始化"></a>6.2 模型与参数初始化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 考察逻辑回归、支持向量机、最近邻、决策树、随机森林、gbdt、xgbGBDT几类算法的性能</span><br>logreg = LogisticRegression()<br>svc = SVC()<br>knn = KNeighborsClassifier(n_neighbors = <span class="hljs-number">5</span>)<br>decision_tree = DecisionTreeClassifier()<br>random_forest = RandomForestClassifier(n_estimators=<span class="hljs-number">300</span>,min_samples_leaf=<span class="hljs-number">4</span>,class_weight=&#123;<span class="hljs-number">0</span>:<span class="hljs-number">0.745</span>,<span class="hljs-number">1</span>:<span class="hljs-number">0.255</span>&#125;)<br>gbdt = GradientBoostingClassifier(n_estimators=<span class="hljs-number">300</span>,learning_rate=<span class="hljs-number">0.05</span>,max_depth=<span class="hljs-number">3</span>)<br>xgb = XGBClassifier(max_depth=<span class="hljs-number">6</span>, n_estimators=<span class="hljs-number">400</span>, learning_rate=<span class="hljs-number">0.02</span>)<br>lgb = LGBMClassifier(max_depth=<span class="hljs-number">6</span>, n_estimators=<span class="hljs-number">300</span>, learning_rate=<span class="hljs-number">0.02</span>)<br>clfs = [logreg, svc, knn, decision_tree, random_forest, gbdt, xgb, lgb]<br><br></code></pre></td></tr></table></figure><h4 id="6-3-网格参数搜索"><a href="#6-3-网格参数搜索" class="headerlink" title="6.3 网格参数搜索"></a>6.3 网格参数搜索</h4><p>sklearn.model_selection库中有GridSearchCV方法，作用是搜索模型的最优参数。<br>我们使用GridSearchCV初步选择参数，后续再不断返回调参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># clfs = [logreg, svc, knn, decision_tree, random_forest, gbdt, xgb, lgb]</span><br><br><span class="hljs-comment">#XGboost 参数搜索</span><br>gsCv = GridSearchCV(xgb,<br>                   &#123;<span class="hljs-string">&#x27;max_depth&#x27;</span>: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>                    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>],<br>                   <span class="hljs-string">&#x27;learning_rate&#x27;</span>:[<span class="hljs-number">0.01</span>,<span class="hljs-number">0.02</span>,<span class="hljs-number">0.03</span>,<span class="hljs-number">0.04</span>]<br>                   &#125;)<br>gsCv.fit(X_all,Y_all)<br><br><span class="hljs-built_in">print</span>(gsCv.best_score_)<br><span class="hljs-built_in">print</span>(gsCv.best_params_)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.8911116690728769&#123;&#39;learning_rate&#39;: 0.02, &#39;max_depth&#39;: 6, &#39;n_estimators&#39;: 400&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#lightgbm 参数搜索</span><br>gsCv = GridSearchCV(lgb,<br>                   &#123;<span class="hljs-string">&#x27;max_depth&#x27;</span>: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>                    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>],<br>                   <span class="hljs-string">&#x27;learning_rate&#x27;</span>:[<span class="hljs-number">0.01</span>,<span class="hljs-number">0.02</span>,<span class="hljs-number">0.03</span>,<span class="hljs-number">0.04</span>]<br>                   &#125;)<br>gsCv.fit(X_all,Y_all)<br><br><span class="hljs-built_in">print</span>(gsCv.best_score_)<br><span class="hljs-built_in">print</span>(gsCv.best_params_)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.8866172870504048&#123;&#39;learning_rate&#39;: 0.02, &#39;max_depth&#39;: 6, &#39;n_estimators&#39;: 300&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#GBDT 参数搜索</span><br>gsCv = GridSearchCV(gbdt,<br>                   &#123;<span class="hljs-string">&#x27;max_depth&#x27;</span>: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],<br>                    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">400</span>,<span class="hljs-number">500</span>],<br>                   <span class="hljs-string">&#x27;learning_rate&#x27;</span>:[<span class="hljs-number">0.04</span>,<span class="hljs-number">0.05</span>,<span class="hljs-number">0.06</span>]<br>                   &#125;)<br>gsCv.fit(X_all,Y_all)<br><br><span class="hljs-built_in">print</span>(gsCv.best_score_)<br><span class="hljs-built_in">print</span>(gsCv.best_params_)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.8899943506371226&#123;&#39;learning_rate&#39;: 0.05, &#39;max_depth&#39;: 3, &#39;n_estimators&#39;: 300&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#KNN 参数搜索</span><br>gsCv = GridSearchCV(knn,<br>                   &#123;<span class="hljs-string">&#x27;n_neighbors&#x27;</span>:[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;)<br>gsCv.fit(X_all,Y_all)<br><br><span class="hljs-built_in">print</span>(gsCv.best_score_)<br><span class="hljs-built_in">print</span>(gsCv.best_params_)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.8529659155106396&#123;&#39;n_neighbors&#39;: 5&#125;</code></pre><h4 id="6-4-K折交叉验证"><a href="#6-4-K折交叉验证" class="headerlink" title="6.4 K折交叉验证"></a>6.4 K折交叉验证</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># K折交叉验证</span><br><br>kfold = <span class="hljs-number">10</span><br>cv_results = []<br><span class="hljs-keyword">for</span> classifier <span class="hljs-keyword">in</span> clfs :<br>    cv_results.append(cross_val_score(classifier, X_all.values, y = Y_all.values, scoring = <span class="hljs-string">&quot;accuracy&quot;</span>, cv = kfold, n_jobs=<span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># cv_results 为8*10的结果矩阵</span><br>cv_means = []<br>cv_std = []<br><span class="hljs-keyword">for</span> cv_result <span class="hljs-keyword">in</span> cv_results:<br>    cv_means.append(cv_result.mean())<br>    cv_std.append(cv_result.std())<br><br>ag = [<span class="hljs-string">&quot;logreg&quot;</span>,<span class="hljs-string">&quot;SVC&quot;</span>,<span class="hljs-string">&#x27;KNN&#x27;</span>,<span class="hljs-string">&#x27;decision_tree&#x27;</span>,<span class="hljs-string">&quot;random_forest&quot;</span>,<span class="hljs-string">&quot;GBDT&quot;</span>,<span class="hljs-string">&quot;xgbGBDT&quot;</span>, <span class="hljs-string">&quot;LGB&quot;</span>]<br>cv_res = pd.DataFrame(&#123;<span class="hljs-string">&quot;CrossValMeans&quot;</span>:cv_means,<span class="hljs-string">&quot;CrossValerrors&quot;</span>: cv_std,<br>                       <span class="hljs-string">&quot;Algorithm&quot;</span>:ag&#125;)<br><br>g = sns.barplot(<span class="hljs-string">&quot;CrossValMeans&quot;</span>,<span class="hljs-string">&quot;Algorithm&quot;</span>,data = cv_res, palette=<span class="hljs-string">&quot;Blues&quot;</span>)<br>g.set_xlabel(<span class="hljs-string">&quot;CrossValMeans&quot;</span>,fontsize=<span class="hljs-number">10</span>)<br>g.set_ylabel(<span class="hljs-string">&#x27;&#x27;</span>)<br>plt.xticks(rotation=<span class="hljs-number">30</span>)<br>g = g.set_title(<span class="hljs-string">&quot;10-fold Cross validation scores&quot;</span>,fontsize=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/output_17_1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示10-fold Cross validation的均值得分结果</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(ag[i],cv_means[i]))<br></code></pre></td></tr></table></figure><pre><code class="hljs">logreg : 0.8731585518102373SVC : 0.8776404494382023KNN : 0.8540823970037452decision_tree : 0.8652559300873908random_forest : 0.8563920099875156GBDT : 0.8832459425717852xgbGBDT : 0.8843820224719101LGB : 0.8799001248439451</code></pre><h4 id="6-5-训练-验证过程可视化"><a href="#6-5-训练-验证过程可视化" class="headerlink" title="6.5 训练/验证过程可视化"></a>6.5 训练/验证过程可视化</h4><p>将模型训练过程的学习曲线打印出来，看下是否存在过拟合/欠拟合情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用sklearn的learning_curve得到training_score和cv_score，使用matplotlib画出learning curve</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_learning_curve</span>(<span class="hljs-params">clf, title, X, y, ylim=<span class="hljs-literal">None</span>, cv=<span class="hljs-literal">None</span>, n_jobs=<span class="hljs-number">3</span>, train_sizes=np.linspace(<span class="hljs-params"><span class="hljs-number">.05</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">5</span></span>)</span>):</span><br>    train_sizes, train_scores, test_scores = learning_curve(<br>        clf, X, y, train_sizes=train_sizes)<br>    train_scores_mean = np.mean(train_scores, axis=<span class="hljs-number">1</span>)<br>    train_scores_std = np.std(train_scores, axis=<span class="hljs-number">1</span>)<br>    test_scores_mean = np.mean(test_scores, axis=<span class="hljs-number">1</span>)<br>    test_scores_std = np.std(test_scores, axis=<span class="hljs-number">1</span>)<br>    <br>    ax = plt.figure().add_subplot(<span class="hljs-number">111</span>)<br>    ax.set_title(title)<br>    <span class="hljs-keyword">if</span> ylim <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        ax.ylim(*ylim)<br>    ax.set_xlabel(<span class="hljs-string">u&quot;train_num_of_samples&quot;</span>)<br>    ax.set_ylabel(<span class="hljs-string">u&quot;score&quot;</span>)<br><br>    ax.fill_between(train_sizes, train_scores_mean - train_scores_std, train_scores_mean + train_scores_std, <br>                     alpha=<span class="hljs-number">0.1</span>, color=<span class="hljs-string">&quot;b&quot;</span>)<br>    ax.fill_between(train_sizes, test_scores_mean - test_scores_std, test_scores_mean + test_scores_std, <br>                     alpha=<span class="hljs-number">0.1</span>, color=<span class="hljs-string">&quot;r&quot;</span>)<br>    ax.plot(train_sizes, train_scores_mean, <span class="hljs-string">&#x27;o-&#x27;</span>, color=<span class="hljs-string">&quot;b&quot;</span>, label=<span class="hljs-string">u&quot;train score&quot;</span>)<br>    ax.plot(train_sizes, test_scores_mean, <span class="hljs-string">&#x27;o-&#x27;</span>, color=<span class="hljs-string">&quot;r&quot;</span>, label=<span class="hljs-string">u&quot;testCV score&quot;</span>)<br><br>    ax.legend(loc=<span class="hljs-string">&quot;best&quot;</span>)<br><br>    midpoint = ((train_scores_mean[-<span class="hljs-number">1</span>] + train_scores_std[-<span class="hljs-number">1</span>]) + (test_scores_mean[-<span class="hljs-number">1</span>] - test_scores_std[-<span class="hljs-number">1</span>])) / <span class="hljs-number">2</span><br>    diff = (train_scores_mean[-<span class="hljs-number">1</span>] + train_scores_std[-<span class="hljs-number">1</span>]) - (test_scores_mean[-<span class="hljs-number">1</span>] - test_scores_std[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> midpoint, diff<br><br>alg_list=[<span class="hljs-string">&#x27;logreg&#x27;</span>, <span class="hljs-string">&#x27;svc&#x27;</span>, <span class="hljs-string">&#x27;knn&#x27;</span>, <span class="hljs-string">&#x27;decision_tree&#x27;</span>, <span class="hljs-string">&#x27;random_forest&#x27;</span>, <span class="hljs-string">&#x27;gbdt&#x27;</span>, <span class="hljs-string">&#x27;xgb&#x27;</span>, <span class="hljs-string">&#x27;lgb&#x27;</span>]<br><br>plot_learning_curve(clfs[<span class="hljs-number">0</span>], alg_list[<span class="hljs-number">0</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">1</span>], alg_list[<span class="hljs-number">1</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">2</span>], alg_list[<span class="hljs-number">2</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">3</span>], alg_list[<span class="hljs-number">3</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">4</span>], alg_list[<span class="hljs-number">4</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">5</span>], alg_list[<span class="hljs-number">5</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">6</span>], alg_list[<span class="hljs-number">6</span>], X_all, Y_all)<br>plot_learning_curve(clfs[<span class="hljs-number">7</span>], alg_list[<span class="hljs-number">7</span>], X_all, Y_all)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(0.8944812361959231, 0.04456088047192275)</code></pre><p><img src="/img/output_74_1.png"></p><p><img src="/img/output_74_2.png"></p><p><img src="/img/output_74_3.png"></p><p><img src="/img/output_74_4.png"></p><p><img src="/img/output_74_5.png"></p><p><img src="/img/output_74_6.png"></p><p><img src="/img/output_74_7.png"></p><p><img src="/img/output_74_8.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_score<br><br><span class="hljs-comment"># 定义集成框架</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bagging</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment"># sklearn机器学习算法的实现都属于estimators的子类：</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,estimators</span>):</span><br>        self.estimator_names = []<br>        self.estimators = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> estimators:<br>            self.estimator_names.append(i[<span class="hljs-number">0</span>])<br>            self.estimators.append(i[<span class="hljs-number">1</span>])<br>        self.clf = LogisticRegression()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, train_x, train_y</span>):</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.estimators:<br>            i.fit(train_x,train_y)<br>        x = np.array([i.predict(train_x) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.estimators]).T<br>        y = train_y<br>        self.clf.fit(x, y)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self,x</span>):</span><br>        x = np.array([i.predict(x) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.estimators]).T<br>        <span class="hljs-comment">#print(x)</span><br>        <span class="hljs-keyword">return</span> self.clf.predict(x)<br>        <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span>(<span class="hljs-params">self,x,y</span>):</span><br>        s = precision_score(y,self.predict(x))<br>        <span class="hljs-comment">#print(s)</span><br>        <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><h4 id="6-6-模型集成与验证（Bagging）"><a href="#6-6-模型集成与验证（Bagging）" class="headerlink" title="6.6 模型集成与验证（Bagging）"></a>6.6 模型集成与验证（Bagging）</h4><p>选择训练结果最好的四个基学习器进行集成（Bagging）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># logreg = LogisticRegression()</span><br><span class="hljs-comment"># random_forest = RandomForestClassifier(n_estimators=300,min_samples_leaf=4,class_weight=&#123;0:0.745,1:0.255&#125;)</span><br><span class="hljs-comment"># gbdt = GradientBoostingClassifier(n_estimators=500,learning_rate=0.03,max_depth=3)</span><br><span class="hljs-comment">#xgb = XGBClassifier(max_depth=3, n_estimators=500, learning_rate=0.03)</span><br><span class="hljs-comment">#clfs = [logreg, svc, knn, decision_tree, random_forest, gbdt, xgb]</span><br><br><span class="hljs-comment"># 选择训练结果最好的四个基学习器集成（Bagging）</span><br><br>bag = Bagging([(<span class="hljs-string">&#x27;xgb&#x27;</span>,xgb),(<span class="hljs-string">&#x27;logreg&#x27;</span>,logreg),(<span class="hljs-string">&#x27;gbdt&#x27;</span>,gbdt), (<span class="hljs-string">&quot;lgb&quot;</span>, lgb)])<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_score<br></code></pre></td></tr></table></figure><p>X_all，Y_all中按照4：1的比例划分训练数据和测试数据，简化起见没有划分验证集（validation data）用于参数调优，使用训练数据训练我们的集成模型。在划分的测试集上进行预测，并计算模型准确率（Accuracy）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">score = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>):<br>    num_test = <span class="hljs-number">0.20</span><br>    X_train, X_cv, Y_train, Y_cv = train_test_split(X_all.values, Y_all.values, test_size=num_test)<br>    bag.fit(X_train, Y_train)<br>    <span class="hljs-comment">#Y_test = bag.predict(X_test)</span><br>    acc_ = <span class="hljs-built_in">round</span>(bag.score(X_cv, Y_cv) * <span class="hljs-number">100</span>, <span class="hljs-number">2</span>)<br>    score+=acc_<br>score/<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">88.43750000000001</code></pre><h3 id="七、进行预测"><a href="#七、进行预测" class="headerlink" title="七、进行预测"></a>七、进行预测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># submission存储了预测结果</span><br>bag.fit(X_all.values, Y_all.values)<br>Y_test = bag.predict(X_test.values).astype(<span class="hljs-built_in">int</span>)<br>submission = pd.DataFrame(&#123;<br>        <span class="hljs-string">&quot;PassengerId&quot;</span>: test_df[<span class="hljs-string">&quot;PassengerId&quot;</span>],<br>        <span class="hljs-string">&quot;Survived&quot;</span>: Y_test<br>    &#125;)<br>submission.to_csv(<span class="hljs-string">r&#x27;predictedData.csv&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h3 id="八、评价与总结"><a href="#八、评价与总结" class="headerlink" title="八、评价与总结"></a>八、评价与总结</h3><ul><li>数据集选择了经典的kaggle数据竞赛中的Titanic数据集。对于我这样的数据科学、机器学习初学者来说，在该数据集基础上可以找到大量来自大神的实现参考，利于快速上手入门；</li><li>没有花时间在’’炼丹’’上，只是使用sklearn.model_selection模块中的网格参数搜索函数GridSearchCV进行了较为简单的参数选择。不过我们还是在训练集和测试集都表现出了较高的精度 ，同时没有明显的过拟合或者欠拟合现象。</li><li>起初只是想学习并做一个使用GBDT算法的小项目（基于XGboost），但是发现了大神使用集成的方法进行过相关的实现，所以虚心进行了学习 (•ิ_•ิ)</li><li>本人知识，经验十分有限，如果有处理不当或者错误的地方还请谅解。</li></ul><h3 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h3><p>｡:.ﾟヽ(｡◕‿◕｡)ﾉﾟ.:｡+ﾟ</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>Kaggle</category>
      
      <category>集成学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集成学习</tag>
      
      <tag>Titanic</tag>
      
      <tag>Kaggle</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python计算圆周率</title>
    <link href="/2022/10/18/Python%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/"/>
    <url>/2022/10/18/Python%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>第一次python上机课，老师找了一个知乎上的问题：“ 圆周率pi比较著名的无穷级数公式有哪些？”<br>好家伙，原来前人研究了这么多使用级数计算圆周率的方法，五种方案的详细叙述在<br><a href="https://www.zhihu.com/question/402311979">https://www.zhihu.com/question/402311979</a></p><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># matplotlib 中文支持</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br><br><span class="hljs-comment"># 根据求解方案一，计算结果和收敛过程</span><br>temp = <span class="hljs-number">0</span><br>n = <span class="hljs-number">0</span><br>x_list = []<br>y_list = []<br><br><span class="hljs-keyword">while</span> n&lt;<span class="hljs-number">628</span>:<br>    temp += (-<span class="hljs-number">1</span>)**n/(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)<br>    Pi = <span class="hljs-number">4</span> * temp    <br>    y_list.append(Pi)<br>    x_list.append(n)<br>    n +=<span class="hljs-number">1</span><br>    <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n从0开始取，项数N=628, value of Pi is &#123;&#125;（四舍五入）&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">round</span>(Pi,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exact value is: &#x27;</span>,Pi)<br><br>plt.plot(x_list, y_list)<br>plt.title(<span class="hljs-string">&#x27;方案一计算收敛图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;N value&#x27;</span>)<span class="hljs-comment"># x轴标题</span><br>plt.ylabel(<span class="hljs-string">&#x27;Pi value&#x27;</span>)  <span class="hljs-comment"># y轴标题</span><br>plt.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">n从0开始取，项数N=628, value of Pi is 3.14（四舍五入）Exact value is:  3.1400002979112887</code></pre><p><img src="/img/output_2_1.png"></p><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据求解方案二，计算结果和收敛过程,由于收敛极快，不便于可视化展示，我们打印输出观察收敛情况。</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleFactorial</span>(<span class="hljs-params">n</span>):</span><br>    ans=<span class="hljs-number">1</span>                         <span class="hljs-comment">#初始值</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n,<span class="hljs-number">0</span>,-<span class="hljs-number">2</span>):    <span class="hljs-comment">#循环遍历</span><br>        ans*=i                    <span class="hljs-comment">#2021*2019*2017*····*3*1</span><br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve2</span>(<span class="hljs-params">N</span>):</span><br>    temp2 = <span class="hljs-number">0</span><br>    n_2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n_2&lt;N:<br>        temp2 += doubleFactorial(<span class="hljs-number">2</span>*n_2+<span class="hljs-number">1</span>)/(doubleFactorial(<span class="hljs-number">2</span>*n_2)*(<span class="hljs-number">2</span>*n_2+<span class="hljs-number">1</span>)*(<span class="hljs-number">2</span>*n_2+<span class="hljs-number">1</span>)*math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>*n_2+<span class="hljs-number">1</span>))<br>        n_2 += <span class="hljs-number">1</span><br>    Pi_2 = <span class="hljs-number">6</span>*temp2<br>    <span class="hljs-keyword">return</span> Pi_2<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n从0开始取，项数N=3, value of Pi is &#123;&#125;（四舍五入后）&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">round</span>(solve2(<span class="hljs-number">3</span>),<span class="hljs-number">2</span>)))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;N=&#123;0&#125;, the exact value of Pi is &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,solve2(i)))<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">n从0开始取，项数N=3, value of Pi is 3.14（四舍五入后）N=0, the exact value of Pi is 0N=1, the exact value of Pi is 3.0N=2, the exact value of Pi is 3.125N=3, the exact value of Pi is 3.1390625N=4, the exact value of Pi is 3.1411551339285717N=5, the exact value of Pi is 3.14151117234003N=6, the exact value of Pi is 3.141576715774867N=7, the exact value of Pi is 3.141589425319122N=8, the exact value of Pi is 3.141591982358383N=9, the exact value of Pi is 3.141592511157863</code></pre><h3 id="方案三："><a href="#方案三：" class="headerlink" title="方案三："></a>方案三：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据求解方案三，计算结果和收敛过程</span><br><br>temp3 = <span class="hljs-number">0</span><br>n_3 = <span class="hljs-number">0</span><br>x_list3 = []<br>y_list3 = []<br><span class="hljs-keyword">while</span> n_3 &lt; <span class="hljs-number">200</span>:<br>    temp3 += <span class="hljs-number">1</span>/(<span class="hljs-number">2</span>*n_3+<span class="hljs-number">1</span>)**<span class="hljs-number">2</span><br>    Pi_3 = math.sqrt(<span class="hljs-number">8</span> * temp3)<br>    y_list3.append(Pi_3)<br>    x_list3.append(n_3)<br>    n_3 += <span class="hljs-number">1</span><br>    <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n从0开始取，项数N=200, value of Pi is &#123;&#125;（四舍五入）&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">round</span>(Pi_3,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exact value is: &#x27;</span>,Pi_3)<br><br>plt.plot(x_list3, y_list3, <span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;方案三计算收敛图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;N value&#x27;</span>)<span class="hljs-comment"># x轴标题</span><br>plt.ylabel(<span class="hljs-string">&#x27;Pi value&#x27;</span>)  <span class="hljs-comment"># y轴标题</span><br>plt.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">n从0开始取，项数N=200, value of Pi is 3.14（四舍五入）Exact value is:  3.140000704127709</code></pre><p>  <img src="/img/output_6_1.png">  </p><h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四:"></a>方案四:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据求解方案四，计算结果和收敛过程</span><br><br>temp4 = <span class="hljs-number">0</span><br>n_4 = <span class="hljs-number">1</span><br>x_list4 = []<br>y_list4 = []<br><span class="hljs-keyword">while</span> n_4&lt;<span class="hljs-number">6</span>:<br>    temp4 += <span class="hljs-number">1</span>/n_4**<span class="hljs-number">4</span><br>    Pi_4 = math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">90</span>*temp4, <span class="hljs-number">1</span>/<span class="hljs-number">4</span>)<br>    y_list4.append(Pi_4)<br>    x_list4.append(n_4)<br>    n_4 += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n从1开始取，项数N=5, value of Pi is &#123;&#125;（四舍五入）&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">round</span>(Pi_4,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exact value is: &#x27;</span>,Pi_4)<br><br>plt.plot(x_list4, y_list4, <span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;方案四计算收敛图&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;N value&#x27;</span>)<span class="hljs-comment"># x轴标题</span><br>plt.ylabel(<span class="hljs-string">&#x27;Pi value&#x27;</span>)  <span class="hljs-comment"># y轴标题</span><br>plt.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">n从1开始取，项数N=5, value of Pi is 3.14（四舍五入）Exact value is:  3.140161179474259</code></pre><p><img src="/img/output_8_1.png">    </p><h3 id="方案五："><a href="#方案五：" class="headerlink" title="方案五："></a>方案五：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;根据求解方案五，计算结果和收敛过程，由于只需极小的N即可达到收敛，</span><br><span class="hljs-string">无需进行可视化，定义计算 Pi 的函数，计算前几个N值观察即可。&#x27;&#x27;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PiCalcute5</span>(<span class="hljs-params">N</span>):</span><br>    n_5 = <span class="hljs-number">0</span><br>    temp5 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n_5 &lt;= N:<br>        temp5 += (math.factorial(<span class="hljs-number">4</span>*n_5)*(<span class="hljs-number">26390</span>*n_5+<span class="hljs-number">1103</span>))/(math.<span class="hljs-built_in">pow</span>(math.factorial(n_5),<span class="hljs-number">4</span>)*math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">396</span>,(<span class="hljs-number">4</span>*n_5)))<br>        n_5 += <span class="hljs-number">1</span><br>    Pi_5 = <span class="hljs-number">9801</span>/(temp5*(<span class="hljs-number">2</span>*math.sqrt(<span class="hljs-number">2</span>)))<br>    <span class="hljs-keyword">return</span> Pi_5<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;While N=1,the estimate value of Pi is &#123;0:.2f&#125;（四舍五入）&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">round</span>(PiCalcute5(<span class="hljs-number">1</span>),<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;n=1, Pi=&#x27;</span>,PiCalcute5(<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;n=2, Pi=&#x27;</span>,PiCalcute5(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;n=3, Pi=&#x27;</span>,PiCalcute5(<span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;n=4, Pi= ...&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">While N=1,the estimate value of Pi is 3.14（四舍五入）n=1, Pi= 3.141592653589794n=2, Pi= 3.141592653589793n=3, Pi= 3.141592653589793n=4, Pi= ...</code></pre><h3 id="求解方案的效率对比："><a href="#求解方案的效率对比：" class="headerlink" title="求解方案的效率对比："></a>求解方案的效率对比：</h3><p>我们还可以计算对比五种求解方案的效率，借助datetime库计算不同计算方案下， 达到指定精确度（3.14）时所用的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> timeit <span class="hljs-keyword">import</span> default_timer <span class="hljs-keyword">as</span> timer<br><br><span class="hljs-string">&#x27;&#x27;&#x27;为了对比五种级数计算算法的效率，我们可以借助datetime库计算不同计算方案下，</span><br><span class="hljs-string">达到指定精确度（3.14）时所用的时间&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 方案一：</span><br>start1 = timer()<br><br>temp1 = <span class="hljs-number">0</span><br>n1 = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n1 &lt; <span class="hljs-number">628</span>:<br>    temp1 += (-<span class="hljs-number">1</span>) ** n1 / (<span class="hljs-number">2</span> * n1 + <span class="hljs-number">1</span>)<br>    n1 += <span class="hljs-number">1</span><br>Pi_1 = <span class="hljs-number">4</span> * temp1<br><br>end1 = timer()<br>t1 = (end1 - start1) * <span class="hljs-number">1000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案一： &#x27;</span>, Pi_1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running time: %s ms&#x27;</span> % t1)<br><br><span class="hljs-comment"># 方案二：</span><br>start2 = timer()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doubleFactorial</span>(<span class="hljs-params">n</span>):</span><br>    ans = <span class="hljs-number">1</span>  <span class="hljs-comment"># 初始值</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">2</span>):  <span class="hljs-comment"># 循环遍历</span><br>        ans *= i  <span class="hljs-comment"># 2021*2019*2017*····*3*1</span><br>    <span class="hljs-keyword">return</span> ans<br><br>temp2 = <span class="hljs-number">0</span><br>n_2 = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n_2 &lt; <span class="hljs-number">3</span>:<br>    temp2 += doubleFactorial(<span class="hljs-number">2</span> * n_2 + <span class="hljs-number">1</span>) / (<br>            doubleFactorial(<span class="hljs-number">2</span> * n_2) * (<span class="hljs-number">2</span> * n_2 + <span class="hljs-number">1</span>) * (<span class="hljs-number">2</span> * n_2 + <span class="hljs-number">1</span>) * math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span> * n_2 + <span class="hljs-number">1</span>))<br>    n_2 += <span class="hljs-number">1</span><br>Pi_2 = <span class="hljs-number">6</span> * temp2<br><br>end2 = timer()<br>t2 = (end2 - start2) * <span class="hljs-number">1000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案二： &#x27;</span>, Pi_2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running time: %s ms&#x27;</span> % t2)<br><br><span class="hljs-comment"># 方案三：</span><br>start3 = timer()<br>temp3 = <span class="hljs-number">0</span><br>n_3 = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> n_3 &lt; <span class="hljs-number">200</span>:<br>    temp3 += <span class="hljs-number">1</span> / (<span class="hljs-number">2</span> * n_3 + <span class="hljs-number">1</span>) ** <span class="hljs-number">2</span><br>    n_3 += <span class="hljs-number">1</span><br>Pi_3 = math.sqrt(<span class="hljs-number">8</span> * temp3)<br><br>end3 = timer()<br>t3 = (end3 - start3) * <span class="hljs-number">1000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案三： &#x27;</span>, Pi_3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running time: %s ms&#x27;</span> % t3)<br><br><span class="hljs-comment"># 方案四：</span><br>start4 = timer()<br>temp4 = <span class="hljs-number">0</span><br>n_4 = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">while</span> n_4 &lt; <span class="hljs-number">6</span>:<br>    temp4 += <span class="hljs-number">1</span> / n_4 ** <span class="hljs-number">4</span><br>    n_4 += <span class="hljs-number">1</span><br><br>Pi_4 = math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">90</span> * temp4, <span class="hljs-number">1</span> / <span class="hljs-number">4</span>)<br>end4 = timer()<br>t4 = (end4 - start4) * <span class="hljs-number">1000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案四： &#x27;</span>, Pi_4)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running time: %s ms&#x27;</span> % t4)<br><br><span class="hljs-comment"># 方案五：</span><br>start5 = timer()<br>n_5 = <span class="hljs-number">0</span><br>temp5 = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n_5 &lt;= <span class="hljs-number">1</span>:<br>    temp5 += (math.factorial(<span class="hljs-number">4</span> * n_5) * (<span class="hljs-number">26390</span> * n_5 + <span class="hljs-number">1103</span>)) / (<br>                math.<span class="hljs-built_in">pow</span>(math.factorial(n_5), <span class="hljs-number">4</span>) * math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">396</span>, (<span class="hljs-number">4</span> * n_5)))<br>    n_5 += <span class="hljs-number">1</span><br>Pi_5 = <span class="hljs-number">9801</span> / (temp5 * (<span class="hljs-number">2</span> * math.sqrt(<span class="hljs-number">2</span>)))<br><br>end5 = timer()<br>t5 = (end5 - start5) * <span class="hljs-number">1000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案五： &#x27;</span>, Pi_5)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running time: %s ms&#x27;</span> % t5)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n各方案时间效率字典为（这里以运行时间衡量）：&quot;</span>)<br>timeEfficiency = &#123;<span class="hljs-string">&#x27;方案一&#x27;</span>: t1, <span class="hljs-string">&#x27;方案二&#x27;</span>: t2, <span class="hljs-string">&#x27;方案三&#x27;</span>: t3, <span class="hljs-string">&#x27;方案四&#x27;</span>: t4, <span class="hljs-string">&#x27;方案五&#x27;</span>: t5&#125;<br><span class="hljs-built_in">print</span>(timeEfficiency)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n使用pandas 的Series数据结构进行更清晰展示：&#x27;</span>)<br>tdata = pd.Series(timeEfficiency)<br><span class="hljs-built_in">print</span>(tdata)<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">方案一：  3.1400002979112887Running time: 0.3793000000769098 ms方案二：  3.1390625Running time: 0.1698999999462103 ms方案三：  3.140000704127709Running time: 0.1720000000204891 ms方案四：  3.140161179474259Running time: 0.14290000012806559 ms方案五：  3.141592653589794Running time: 0.11979999999311985 ms各方案时间效率字典为（这里以运行时间衡量）：&#123;&#39;方案一&#39;: 0.3793000000769098, &#39;方案二&#39;: 0.1698999999462103, &#39;方案三&#39;: 0.1720000000204891, &#39;方案四&#39;: 0.14290000012806559, &#39;方案五&#39;: 0.11979999999311985&#125;使用pandas 的Series数据结构进行更清晰展示：方案一    0.3793方案二    0.1699方案三    0.1720方案四    0.1429方案五    0.1198dtype: float64</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文写作小记（LaTex）</title>
    <link href="/2022/02/06/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E5%B0%8F%E8%AE%B0%EF%BC%88LaTex%EF%BC%89/"/>
    <url>/2022/02/06/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E5%B0%8F%E8%AE%B0%EF%BC%88LaTex%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>因为参加数模美赛和国赛的缘故，接触了<strong>LaTex</strong>，本文介绍了一些常用用法，以及模板的使用。</p><p>美赛模板和国赛模板可以在<a href="https://www.latexstudio.net/">https://www.latexstudio.net/</a> 或者 <strong>github</strong> 上下载，一般下载最新的版本，以满足组委会对格式的要求，不过每年的要求变化都不大，注意国赛Latex源文件一般需要选择<strong>Xelatex</strong>方式进行编译。</p><span id="more"></span><h1 id="论文写作小记（LaTex）"><a href="#论文写作小记（LaTex）" class="headerlink" title="论文写作小记（LaTex）"></a>论文写作小记（LaTex）</h1><p>下面这张图直观地描述了latex是什么(๑•̀ㅂ•́) ✧</p><p><img src="/img/latex.png"></p><h2 id="01-字体规范"><a href="#01-字体规范" class="headerlink" title="01.字体规范"></a>01.字体规范</h2><ul><li><p>加粗 \textbf{…} ：可用于表格、图片的标签；列表</p></li><li><p>意大利斜体 \textit{…} : 用于模型，方法，段落关键词的强调</p><pre><code class="hljs"> \item \textbf&#123;...&#125;</code></pre></li><li><p>小字母大写 \textsc{…} ：例如 \textsc{Task 1}</p></li><li><p>无衬线字体 \textsf{…} : 例如 4-3-3 展示 </p></li><li><p>等宽字体 \texttt{…} : 例如M2的处理</p></li></ul><h2 id="02-间距调节"><a href="#02-间距调节" class="headerlink" title="02.间距调节"></a>02.间距调节</h2><ul><li><p>强制换行：可使用\\或 \linebreak, </p><p>如果在单词中间，我们不希望换行可以使用˜连接，即不会断行的空格。</p></li><li><p>强制分页：可用 \newpage, \clearpage 或 \pagebreak</p></li><li><p>空格：(数值与单位之间没有空格)</p><ul><li>强制空格: \␣</li><li>\quad：产生一段宽度为 1em 的水平空白</li><li>\qquad：\quad 的两倍</li><li>,：大约为 \quad 的 3/18</li></ul></li><li><p>垂直间距：\vspace{高度}：产生指定高度的垂直空白，如 \vspace{4pt}</p></li></ul><h2 id="03-列表使用"><a href="#03-列表使用" class="headerlink" title="03.列表使用"></a>03.列表使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex">无序列表<br>\begin&#123;itemize&#125;<br>　　\item 标签 条目内容<br>\end&#123;itemize&#125;<br>有序列表<br>\begin&#123;enumerate&#125;[可选格式]<br>　　\item 标签 条目内容<br>\end&#123;enumerate&#125;<br>eg.<br>\begin&#123;enumerate&#125;[\bfseries \textit&#123;Step&#125; 1:]<br>\item AAA<br>\item BBB<br>\item CCC<br>\end&#123;enumerate&#125;<br></code></pre></td></tr></table></figure><h2 id="04-交叉引用"><a href="#04-交叉引用" class="headerlink" title="04.交叉引用"></a>04.交叉引用</h2><ul><li><p>章节、公式、图表、定理等位置使用\label 命令之后在别处使用\ref 或\pageref 命令，生成交叉引用的编号和页码</p></li><li><p>数模论文中，一般交叉引用主要出现的有以下几种情况：</p><ul><li><p>图表的交叉引用：在图表标题命令\caption 之后紧接着使用。</p></li><li><p>章节的交叉引用：在章节标题命令\section 等之后紧接着使用。</p></li><li><p>公式的交叉引用:  </p><ol><li><p>标签\label：单行公式在公式内任意位置使用；多行公式在每一行</p><p>公式的任意位置使用。</p></li><li><p>引用\eqref：amsmath 的\eqref 命令能够为引用自动加上圆括号。</p></li></ol></li><li><p>参考文献的引用：</p><ul><li><p>在前面我们使用\bibitem 定义时，后面 {} 中的内容便自动生</p><p>成标签，供我们引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\bibitem&#123;1&#125; Leighton, F. Thomson. \emph&#123;Introduction to parallel algorithms and architectures: array, trees, hypercubes&#125;. 2014.<br></code></pre></td></tr></table></figure><p>在引用处，只需要使用\upcite{标签号} 即可引用。</p></li><li><p>\url：生成网址的同时在页面上输出其内容</p><p>\href：生成网址的同时在页面上输出文本的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\url&#123;网址&#125;<br>\href&#123;网址&#125;&#123;文本&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="05-公式微调"><a href="#05-公式微调" class="headerlink" title="05.公式微调"></a>05.公式微调</h2><ul><li><p>在行内公式中，巨算符 (∑, ∏, ∫ ) 的上下标往往会被放置到右侧，同时分数（fraction）也会变小</p><ul><li><p>利用巨算符、分数本身的缩放 (优雅)</p><ul><li>巨算符：\limits(上下方)，\nolimits(右方)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">$\sum\limits_&#123;i=1&#125;^n$<br></code></pre></td></tr></table></figure><ul><li>分数：\dfrac(正常)，\tfrac(缩小版)</li></ul></li><li><p>使用万能的\displaystyle 命令 (快捷)</p><ul><li>在行内公式出现前使用\displaystyle命令 (不带参数)，即可将行内公式完全转化为行间公式 </li></ul></li></ul></li><li><p>多行公式</p><ul><li>利用 align 环境使两个符号处对齐</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;align&#125;<br>a &amp; = b + c \\<br>  &amp; = d + e<br>\end&#123;align&#125;  <br></code></pre></td></tr></table></figure><ul><li>利用 gather 环境进行公式的居中对齐; 如果我们不需要按等号对齐，只需罗列数个公式，gather 将是一个很好用的环境：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;gather&#125;<br>a = b + c \\<br>d = e + f + g \\<br>h + i = j + k \notag \\<br>%不标号<br>l + m = n<br>\end&#123;gather&#125;<br></code></pre></td></tr></table></figure><ul><li><p>加 * 后缀，即 align* 和 gather* 环境，</p><pre><code class="hljs">    同样已经囊括数学环境，但是他不会对公式进行编号。</code></pre></li></ul></li></ul><h2 id="06-图表处理"><a href="#06-图表处理" class="headerlink" title="06.图表处理"></a>06.图表处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;figure&#125;[htbp]<br>　　\centering<br>　　\includegraphics[选项]&#123;图形文件名 (相对位置且含后缀)&#125;<br>　　\caption&#123;图片标题&#125;<br>　　\label&#123;图片标签&#125;<br>\end&#123;figure&#125;<br><br>%eg.<br>\begin &#123; figure &#125;[ htbp ]<br>\centering<br>\includegraphics [ width =.9\ textwidth ]&#123; XXX . pdf &#125; % 图片相对位置 <br>\caption &#123; Electric Vehicles : January 2020&#125; % 图 片 标 题 5 <br>\label &#123; fig : American &#125; % 图 片 标 签 6 <br>\end &#123; figure &#125;<br><br></code></pre></td></tr></table></figure><ul><li>常用 [选项] 有:<ul><li>width, height <em>→</em> 指定图形的宽度和高度</li><li>scale <em>→</em> 缩放因子, 如 scale=0.8</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">% eg.<br>\includegraphics[scale=0.2]&#123;tiger.png&#125;<br>\includegraphics[width=2.5cm]&#123;tiger.png&#125;<br>\includegraphics[width=0.3\textwidth]&#123;tiger.png&#125;<br></code></pre></td></tr></table></figure><ul><li><p>格式选择：</p><ul><li><p>eps：eps 是一种传统的矢量图，一般期刊在接受稿件时，要求将所</p><p>有图片都转化成 eps。eps 主要的获取途径为MATLAB直接导出。利</p><p>用 pdfLATEX 需要转化成 pdf 编译。</p></li><li><p>pdf：pdf 也是一种很好的矢量图格式，因为它的获取来源非常广。</p><p>一般软件都具备打印功能，利用虚拟打印机即可获得清晰的 pdf 文</p><p>件，但美中不足的是，打印的图片可能需要裁剪白边。</p></li></ul></li><li><p>多图模式</p><ul><li><p>子图格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin &#123; figure &#125;[ htbp ]<br>\centering<br>\subfigure [ Hot Map of one Room ]&#123; % 图 片 1([] 内 为 子 图 标 题) <br>\label &#123; fig : sub . roomhot &#125; % 子 图 1 的 标 签  <br>\includegraphics [ width =0.45\ textwidth ]&#123; XXX . jpg &#125;&#125;% 子图1位置  <br>\subfigure [ Hot Map of one Floor ]&#123; % 图 片 2  <br>\label &#123; fig : sub . floorhot &#125; % 子 图 2 的 标 签  <br>\includegraphics [ width =0.45\ textwidth ]&#123; XXX . jpg &#125;&#125;% 子 图 2 位 置 <br>\caption &#123; Hot Map of one Room and one Floor &#125; % 总 图 标 题<br>\label &#123; fig : hot &#125; % 总 图 标 签<br>\end &#123; figure &#125;<br>%一般几张图片的宽度和&lt; 1\textwidth<br></code></pre></td></tr></table></figure></li><li><p>更多多图格式：<a href="https://www.bilibili.com/video/BV1tA411t7U9?from=search&seid=16113954067034039980&spm_id_from=333.337.0.0">b站多图排版</a></p></li></ul></li><li><p>表格操作</p><ul><li><p>\hline: 与表格同宽的水平线</p></li><li><p>\cline{m-n}: 从第 <em>m</em> 列开始到第 <em>n</em> 列结束的水平线</p></li><li><p>使用 booktabs 宏包的三线表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">顶端的\toprule<br>标题行和内容间的\midrule<br>表格结束的\bottomrule<br></code></pre></td></tr></table></figure></li><li><p>在 LaTeX 中横向合并单元格较为容易，直接使用 \multicolumn{列数}{对齐方式}{内容} 即可。</p></li><li><p>而纵向合并单元格则需要用到 multirow 宏包，然后采用 \multirow{列数}{宽度}{内容}。这两个语句仅在第二个命令有所区别。在\multirow中的宽度可以填*以使用自然宽度。</p></li><li><p>在普通表格中一般采用\cline{i-j}实现，而在三线表中则利用\cmidrule{i-j}实现</p></li></ul><h2 id="07-模板的修改"><a href="#07-模板的修改" class="headerlink" title="07.模板的修改"></a>07.模板的修改</h2><p>​    在XXX.cls源文件中进行模板样式的修改，一般不建议进行大的改动，遇到特殊困难可以查资料或者尝试寻找模板作者解决。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>文档/论文写作</category>
      
      <category>论文写作</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>论文写作</tag>
      
      <tag>数模竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Markdown写文档</title>
    <link href="/2021/10/03/%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E6%96%87%E6%A1%A3/"/>
    <url>/2021/10/03/%E4%BD%BF%E7%94%A8Markdown%E5%86%99%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>[toc]</p><h3 id="标题：1-6级"><a href="#标题：1-6级" class="headerlink" title="标题：1-6级"></a>标题：1-6级</h3><ul><li>快捷方式：Ctrl+1-6  </li><li>转义字符：#的数量表示级数  注意#和文本有个空格</li><li>四个#号控制的标题-四级标题  #### 四级标题</li></ul><h3 id="序列："><a href="#序列：" class="headerlink" title="序列："></a>序列：</h3><ul><li><p>快捷方式</p><ol><li>有序列表 Ctrl+shift+[</li><li>无序列表 Ctrl+shift+]</li></ol></li><li><p>转义字符<br>有序列表  在空白的一行输入 1.空格 即可实现缩进排序的效果<br>无序列表  在空白的一行输入 -空格    空格可以理解为转义字符</p></li><li><p>先enter进入下一个序列；一行未输入内容前 按下tab键可以进行二级列表， 即列表的列表 （以此类推）</p></li><li><ul><li>二级列表</li></ul></li></ul><h3 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h3><p>Ctrl+B/I/U = 加粗/斜体/下划线  </p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul><li><del>删除线~~~ 双波浪可以和高亮显示的双等号一起记忆  ~~无快捷键</del></li><li>$公式$    $e^2$  <img src="https://www.zhihu.com/equation?tex=e%5E2" alt="[公式]"> </li></ul><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul><li><p>语法：空格-空格[ 内1空格 ]空格    </p></li><li><p><input checked="" disabled="" type="checkbox"> </p></li><li><p><input disabled="" type="checkbox"> </p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><!--这是一段注释-->   只会在预览时显示  导出图片 /pdf等文件不会显示<h3 id="Emoji图标"><a href="#Emoji图标" class="headerlink" title="Emoji图标"></a>Emoji图标</h3><ul><li>空格:代号  :后面跟Emoji图标的代号  代号不是很严格  有联想功能  例如  :up  显示如下</li><li>是一个小手朝上的emoji</li></ul><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>— 在空白一行输入三个（或以上）-或者*即实现分割线的效果</p><hr><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul><li>快捷键 Ctrl+T</li><li>转义字符特别复杂 不如用快捷键</li></ul><h3 id="特殊块"><a href="#特殊块" class="headerlink" title="特殊块"></a>特殊块</h3><ul><li><p>Ctrl+Shift+K = 代码</p></li><li><p>Ctrl+Shift+M = 公式</p></li><li><p>Ctrl+Shift+Q = 引用</p></li></ul><h3 id="代码模式"><a href="#代码模式" class="headerlink" title="代码模式"></a>代码模式</h3><ul><li>代码模式切换 Ctrl+/  </li><li>顺口溜：尖波浪双等号 </li><li>^   ^         我是^上标^  </li><li>~   ~         我是<del>下标</del></li><li>==   ==    ==高亮==</li></ul><h3 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h3><ul><li>快捷键 Ctrl+shift+i</li><li><img src="" alt="图的名字">   立马转化为在小括号中选取文件路径 </li></ul><p><strong>超链接</strong></p><ul><li>快捷键 Ctrl+K</li><li><a href="">链接提示语</a>  同插图理 小括号里面放入目的网址的路径</li><li><a href="https://e-alan.github.io/">我的博客主页</a></li></ul><h3 id="表格：代码模式"><a href="#表格：代码模式" class="headerlink" title="表格：代码模式"></a>表格：代码模式</h3><p>代码模式  （这个必须切换到代码模式才能看清楚到底发生了什么 第二行不可少 虽然是空的）</p><p>| 姓名 | 性别 | 生日     | </p><p>| —- | —-| ——–   |</p><p>| 张三 | 男   | 19970101 |</p><p>| 李四 | 男   | 19970601 |</p><p>效果如下表所示：</p><table><thead><tr><th>姓名</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>19970101</td></tr><tr><td>李四</td><td>男</td><td>19970601</td></tr></tbody></table><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li>```+代码类别</li><li>```三飘号(数字1左边的那个下符号)+代码标题+enter+enter 切换到代码模式   </li><li>第一个enter是确认标题 第二个enter是激活代码模式  第二个才是核心</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hello world !<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>&gt;+内容  在&gt;的后面输入内容即可  但是&gt;需要在一行的最前端 </p><blockquote><p>人望山，鱼窥荷。</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[^数字]     正文中进行引用的语法（内容写在前）  解释：^后面跟数字自动转换成引用格式[]   </p><p>[^数字]： 与之对应的文末文献简介的语法   解释：原有基础上加个冒号：即可  </p><h3 id="目录生成"><a href="#目录生成" class="headerlink" title="目录生成"></a>目录生成</h3><p>[toc]  后面跟回车即可变换为显示的目录样式  toc是table of contents的缩写 </p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>语法注释：```+flow 关键字来实现流程图样式的转义   还有其他关键字来显示其他形式流程图  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs flow"><br></code></pre></td></tr></table></figure><h2 id="底层操作"><a href="#底层操作" class="headerlink" title="底层操作"></a>底层操作</h2><h3 id="Html-CSS"><a href="#Html-CSS" class="headerlink" title="Html+CSS"></a>Html+CSS</h3><p>从底层代码的角度修改CSS代码文件来实现高度自定义的主题样式 </p><ol><li>从官网下载目标样式的模板文件夹</li><li>把文件夹里面的CSS文件粘贴出来与文件夹并列</li><li>打开CSS文件 通过修改代码 局部微调主题样式、大小 、字体、 颜色之类</li></ol><h2 id="一些快捷键（Typora）"><a href="#一些快捷键（Typora）" class="headerlink" title="一些快捷键（Typora）"></a>一些快捷键（Typora）</h2><p>新建 CTRL + N</p><p>保存 CTRL + S</p><p>另存为 CTRL + SHIFT + S</p><p>一级标题: CTRL + 1</p><p>二级标题: CTRL + 2</p><p>三级标题: CTRL + 3</p><p>四级标题 : CTRL + 4</p><p>五级标题 : CTRL + 5</p><p>六级标题 : CTRL +6</p><p>插入表格: CTRL + T</p><p>插入引用: CTRL + SHIFT + Q</p><p>有序列表: CTRL + SHIFT + [</p><p>无序列表: CTRL + SHIFT + ]</p><p>代码块: CTRL + SHIFT + K</p><p>字体加粗: CTRL + B</p><p>超链接: CTRL + K</p><p>插入图片: CTRL + SHIFT +l</p><p>显示/隐藏侧边栏: CTRL + SHIFT + L</p><p>打开/关闭源代码模式: CTRL + /</p><p>全文查找: CTRL + F</p><p>全文替换: CTRL + H</p><p>开发者工具: SHIFT + F12</p><p>跳转到文首: CTRL + Home</p><p>跳转到文末 : CTRL + End</p><p>注：上面跳转文首、文末 HOME键 和 End键位置：（右边上下左右键的 上方有6个键，中间2个就是Home和End键）</p>]]></content>
    
    
    <categories>
      
      <category>文档/论文写作</category>
      
      <category>文档写作</category>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>文档写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
